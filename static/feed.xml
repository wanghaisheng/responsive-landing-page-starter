<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>Vonage Developer Blog</title>
        <link></link>
        <description>Vonage Developer Blog feed!</description>
        <lastBuildDate>Sun, 12 Apr 2020 16:25:16 GMT</lastBuildDate>
        <docs>http://blogs.law.harvard.edu/tech/rss</docs>
        <generator>https://github.com/nuxt-community/feed-module</generator>
        <item>
            <title><![CDATA[Building a Slack Clone Using Vue.js - Part 1]]></title>
            <link>/blog/building-a-slack-clone-vuejs-part-1</link>
            <guid>/blog/building-a-slack-clone-vuejs-part-1</guid>
            <description><![CDATA[Have you ever wanted to create a chat application? Learn how to make your own Slack in this multi-part Vue.js series]]></description>
            <content:encoded><![CDATA[<p>Have you ever wanted to create a chat application, but get stuck on features to add, or just how to make it generally? In this post, you get to build a clone of everyone's favourite chat software, Slack. Using Vue.js, everyone's favourite framework. And, Vonage Conversation API, everyone's favourite conversation service.</p>
<p>This post is part 1 of a multi-part tutorial series that's going to go from an empty directory to a real-world application featuring many of Slacks genre-defining features.</p>
<p>Here are some of the things you'll learn in this post:</p>
<ul>
<li><a href="#generate-an-express.js-server">Generate an Express.js Server</a></li>
<li><a href="#routes-and-controllers">Express.js Routes and Controllers</a></li>
<li><a href="#hot-reloading-the-expressjs-server-files">Hot Reloading the Express.js Server Files</a></li>
<li><a href="#generate-a-vuejs-client">Generate a Vue.js Client</a></li>
<li><a href="#run-the-server-and-client-concurrently">Run the Server and Client Concurrently</a></li>
<li><a href="#proxy-api-requests-to-the-express.js-server">Proxy API Requests to the Express.js Server</a></li>
<li><a href="#loading-screens-with-tailwind-and-fontawesome">Loading Screens with Tailwind and FontAwesome</a></li>
<li><a href="#handle-server-errors-in-the-client">Handle Server Errors in the Client</a></li>
<li><a href="#use-dotenv-environment-files">Use Dotenv Environment Files</a></li>
<li><a href="#connect-to-vonage-conversation-api">Connect to Vonage Conversation API</a></li>
<li><a href="#create-the-chat-components">Create the Chat Components</a></li>
</ul>
<p>If you're interested in the demo app complete, skipping the guide completely, please check out the <a href="https://github.com/nexmo-community/vuejs-slack-clone/tree/part-1">GitHub repo for my Vue.js Slack clone</a> so far.</p>
<h2>Prerequisites</h2>
<h3>Node &amp; NPM</h3>
<p>To get started, you're going to need Node and NPM installed. This guide uses Node 8 and NPM 6. Check they're installed and up-to-date.</p>
<pre><code class="language-shell">node --version
npm --version
</code></pre>
<blockquote>
<p>Both Node and NPM need to be installed and at the correct version. <a href="https://nodejs.org/">Go to nodejs.org</a>, download and install the correct version if you don't have it.</p>
</blockquote>
<h3>Our CLI</h3>
<p>To set up your application, you'll need to install <a href="https://www.npmjs.com/package/nexmo-cli">our CLI</a>. Install it using NPM in the terminal.</p>
<pre><code class="language-shell">npm install -g nexmo-cli@beta
</code></pre>
<p>You can check you have the correct version with this command. At the time of writing, I was using version <code>0.4.9-beta-3</code>.</p>
<pre><code class="language-shell">nexmo --version
</code></pre>
<p>To follow along with the steps in this article, remember to <a href="https://dashboard.nexmo.com/sign-up?utm_source=DEV_REL&amp;utm_medium=github&amp;utm_campaign=https://github.com/nexmo-community/vuejs-slack-clone">sign up for a free Vonage account</a> and configure the CLI with the API key and secret found on your dashboard.</p>
<pre><code class="language-shell">nexmo setup &lt;your_api_key&gt; &lt;your_api_secret&gt;
</code></pre>
<h3>Express.js CLI</h3>
<p>Install <a href="https://expressjs.com/en/starter/generator.html">Express Generator</a>. You will use this library to generate a basic Express.js server.</p>
<pre><code class="language-shell">npm install -g express-generator
</code></pre>
<p>You can check you have the correct version with this command. At the time of writing, I was using version <code>4.16.1</code>.</p>
<pre><code class="language-shell">express --version
</code></pre>
<h3>Vue.js CLI</h3>
<p>Install the <a href="https://cli.vuejs.org/">Vue CLI</a>. You will use this library to generate a basic Vue.js client application.</p>
<pre><code class="language-shell">npm install -g @vue/cli
</code></pre>
<p>You can check you have the correct version with this command. At the time of writing, I was using version <code>4.1.2</code> of <code>@vue/cli</code>.</p>
<pre><code class="language-shell">vue --version
</code></pre>
<h2>Starting From Scratch</h2>
<p>This series is going to take you from a blank directory right through to a real-world chat application using Express.js as a server.</p>
<h3>Create a Project Folder</h3>
<p>First thing first, create a directory for your work.</p>
<pre><code class="language-shell">mkdir vuejs-slack-clone
</code></pre>
<p>And, change into the new directory.</p>
<pre><code class="language-shell">cd vuejs-slack-clone
</code></pre>
<h3>Generate an Express.js Server</h3>
<p>Next, create a basic server using the Express.js generator. The thing I love about this CLI is that it configures the server executable and application independently of each other. Meaning, it takes the philosophy of the extremely lightweight and cool <a href="https://expressjs.com/en/starter/hello-world.html">Express Hello World</a>. It splits it into the equally cool executable file for configuring the server and the environment <code>bin/www</code>, and the application itself <code>app.js</code>.</p>
<p>Because the application is predominately an API, it's better to skip installing anything used for handling template files. For this, use the <code>--no-view</code> option.</p>
<p>If you plan on using <code>git</code> as your version-control system, you should consider using <code>--git</code> to generate the correct <code>.gitignore</code> file.</p>
<p>Because you're already in the project directory, specify the <code>--force</code> option and use <code>.</code> as the directory. Then, the tool will generate the application in the current directory without issue.</p>
<pre><code class="language-shell">express --git --no-view --force .
</code></pre>
<p>Then, install dependencies.</p>
<pre><code class="language-shell">npm install
</code></pre>
<h3>Run the Express.js Server Locally</h3>
<p>Once the server has been created and the dependencies installed, you can go ahead and start it to make sure everything is working as expected.</p>
<pre><code class="language-shell">npm start
</code></pre>
<p>You can check it's working at the default URL, <a href="http://localhost:3000">localhost:3000</a>.</p>
<p><img src="/content/blog/building-a-slack-clone-using-vue-js-part-1/basic-express-server-running.png" alt="Screenshot of a basic Express.js server running" title="Screenshot of a basic Express.js server running"></p>
<h2>Routes and Controllers</h2>
<p>The generated application includes the necessary routing. Routing refers to determining how an application handles a request to a particular URL and method (GET, POST, etc.). Controllers, on the other hand, are responsible for the flow of the application execution. The generated application doesn't create and controllers and uses the routers to return a response.</p>
<p>Create a new controller directory.</p>
<pre><code class="language-shell"># mkdir is a command that makes a directory
mkdir controllers
</code></pre>
<p>Create a new controller in this directory named <code>server.js</code>.</p>
<pre><code class="language-shell"># touch is a command that will create an empty file
touch controllers/server.js
</code></pre>
<p>Open <code>controllers/server.js</code> and create the first method for the server.</p>
<pre><code class="language-js">// controllers/server.js
exports.status = function(req, res, next) {
  res.json({
    status: 'ok'
  });
};
</code></pre>
<p>This controller could later be responsible for providing the client with a condition, driven by various checks like if the chat service is up and running or whether it can connect to the data. The idea is that if any issues occur on the server, the client will receive the error, gracefully handle it, and inform the user what has happened.</p>
<p>To request this controller method, create a new route in the existing routes directory named <code>server.js</code>.</p>
<pre><code class="language-shell">touch routes/server.js
</code></pre>
<p>Open <code>routes/server.js</code> and add the code shown below.</p>
<pre><code class="language-js">// routes/server.js
var express = require('express');
var router = express.Router();

var serverController = require('../controllers/server');

router.get('/status', serverController.status);

module.exports = router;
</code></pre>
<p>This routes a path (<code>/status</code>) to a controller method (<code>serverController.status</code>). The route delivers the result of the controller method to the client as a response.</p>
<p>To add this route to the app, you need to edit <code>app.js</code> and make these changes.</p>
<pre><code class="language-diff">// app.js
- var indexRouter = require('./routes/index');
- var usersRouter = require('./routes/users');

...

- app.use('/', indexRouter);
- app.use('/users', usersRouter);
+ app.use('/api/server', require('./routes/server'));
</code></pre>
<p>Then you can go ahead and delete the <code>routes/index.js</code> and <code>routes/users.js</code> files.</p>
<p>Start the application again with <code>npm start</code>; then you can access the new route at <a href="http://localhost:3000/api/server/status">localhost:3000/api/server/status</a>.</p>
<p><img src="/content/blog/building-a-slack-clone-using-vue-js-part-1/server-status-api-endpoint.png" alt="Screenshot of a basic server status API endpoint" title="Screenshot of a basic server status API endpoint"></p>
<h2>Creating a Client</h2>
<p>Use the Vue CLI to create a new client application.</p>
<h3>Generate a Vue.js Client</h3>
<p>Run the create command with the Vue CLI. This tool generates a simple Vue application to base our chat client off. It prompts with some options, and you can select the defaults.</p>
<pre><code class="language-shell">vue create client
</code></pre>
<p>The client is generated in the <code>client</code> directory as specified in the command. It also runs <code>npm install</code> automatically.</p>
<p>Now, change into the <code>client</code> directory.</p>
<pre><code class="language-shell">cd client
</code></pre>
<p>To run the client, use this command. Notice, it is different from how you run the server.</p>
<pre><code class="language-shell">npm run serve
</code></pre>
<p>Then you can access your client at <a href="http://localhost:8080">localhost:8080</a>. You'll notice it has a different port by default and in the development environment this helps us as you'll find out next as we run the server and client concurrently.</p>
<p><img src="/content/blog/building-a-slack-clone-using-vue-js-part-1/basic-vue-client-running.png" alt="Screenshot of a basic Vue.js client running" title="Screenshot of a basic Vue.js client running"></p>
<h2>Hot Reloading the Express.js Server Files</h2>
<p>Usually, in the development process, most people like the application to automatically reload the files as they edit them. To do this, we'll set up the server to use <a href="https://www.npmjs.com/package/nodemon">nodemon</a> to serve the files.</p>
<h3>Install Nodemon</h3>
<p>If you're still in the <code>client</code> directory from earlier, you can change back to the projects main directory by going up a level with this command, <code>..</code> denoting a parent directory.</p>
<pre><code class="language-shell">cd ..
</code></pre>
<p>Now, install Nodemon as a development dependency. Install a development dependency by adding <code>--save-dev</code> as an option of the command.</p>
<pre><code class="language-shell">npm install nodemon --save-dev
</code></pre>
<p>Once installed, you can edit the <code>package.json</code> file and modify the <code>start</code> script as shown here.</p>
<pre><code class="language-diff">+     &quot;dev:server&quot;: &quot;nodemon ./bin/www&quot;,
      &quot;start&quot;: &quot;node ./bin/www&quot;
</code></pre>
<p>When you run the application with <code>npm run dev:server</code>, it will use Nodemon. Nodemon watches the application files and restarts the service automatically when any files change.</p>
<blockquote>
<p><em><strong>Note:</strong></em> This also includes file metadata like permissions and modified date.</p>
</blockquote>
<h2>Run the Server and Client Concurrently</h2>
<p>As we progress in this guide, you're going to need to run both the client and Express.js concurrently. There is a <a href="https://www.npmjs.com/package/concurrently">Concurrently</a> package for that, which makes it very easy to lean separate applications on each other.</p>
<h3>Install Concurrently</h3>
<p>Install Concurrently, also as a development dependency.</p>
<pre><code class="language-shell">npm install concurrently --save-dev
</code></pre>
<h3>Start Both Dev Environments</h3>
<p>Modify the <code>package.json</code> file for the server, as shown here. In the last section, we added a <code>dev:server</code> script which ran the server using Nodemon. Now, we're adding a <code>dev:client</code> script at the root level of the project to run the client from here too.</p>
<pre><code class="language-diff">      &quot;dev:server&quot;: &quot;nodemon ./bin/www&quot;,
+     &quot;dev:client&quot;: &quot;cd client &amp;&amp; npm run serve&quot;,
      &quot;start&quot;: &quot;node ./bin/www&quot;
</code></pre>
<p>Now, add this line to combine the two using Concurrently. You'll notice the option <code>--kill-others-on-fail</code> which means that concurrently will stop all services if a hard error is detected. Without this, if Node or Webpack (which serves the client) encountered an error, you would need to restart Concurrently to get both client and server running again.</p>
<pre><code class="language-diff">      &quot;dev:server&quot;: &quot;nodemon ./bin/www&quot;,
      &quot;dev:client&quot;: &quot;cd client &amp;&amp; npm run serve&quot;,
+     &quot;dev&quot;: &quot;concurrently --kill-others-on-fail 'npm run dev:server' 'npm run dev:client'&quot;,
      &quot;start&quot;: &quot;node ./bin/www&quot;
</code></pre>
<p>When you run the application with <code>npm run dev</code>, it will start both server and client together at <a href="http://localhost:3000">localhost:3000</a> and <a href="http://localhost:8080">localhost:8080</a> respectfully.</p>
<p><img src="/content/blog/building-a-slack-clone-using-vue-js-part-1/server-and-client-running-concurrently.png" alt="Screenshot of an Express.js and Vue.js running concurrently" title="Screenshot of an Express.js and Vue.js running concurrently"></p>
<h2>Proxy API Requests to the Express.js Server</h2>
<p>To make requests in the development environment to the server from the client, you'll set up a proxy. You can configure Vue.js to proxy any requests beginning with a particular route.</p>
<h3>Configure the Proxy</h3>
<p>To do this, create a new file inside the <code>client</code> directory named <code>vue.config.js</code>. So change into the client directory.</p>
<pre><code class="language-shell">cd client
</code></pre>
<p>Create an empty config file.</p>
<pre><code class="language-shell"># touch is a command that will create an empty file
touch vue.config.js
</code></pre>
<p>Paste in the following code.</p>
<pre><code class="language-js">// vue.config.js

module.exports = {
  devServer: {
    proxy: {
      &quot;/api&quot;: {
        target: &quot;http://localhost:3000&quot;,
        secure: false
      }
    }
  }
};
</code></pre>
<p>This code tells Vue.js that when running <code>devServer</code> that any routes matching <code>/api</code> should proxy to <code>http://localhost:3000</code>. This is the URL for the server when you run the <code>dev</code> script, or the <code>dev:server</code> script directly.</p>
<h3>Create an API Consumer Service</h3>
<p>To make requests from Vue.js to our server from the client, install <a href="https://www.npmjs.com/package/axios">Axios</a>, which is a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">Promise</a> based HTTP client to use in browser-side code.</p>
<pre><code class="language-shell">npm install axios
</code></pre>
<p>Now, you have Axios installed and you can proxy requests between the server and client, it's time to make those requests. In the client's <code>src/</code> directory, make a new directory named <code>services</code> to contain all of the API service files.</p>
<pre><code class="language-shell">mkdir src/services
</code></pre>
<p>Create an abstract API service, which will set the path for subsequent API services. Remember, in the development environment, <code>/api</code> is going to proxy to the server.</p>
<pre><code class="language-shell">touch src/services/Api.js
</code></pre>
<p>Use the following code to create an abstract API service that returns an Axios instance.</p>
<pre><code class="language-js">// src/services/Api.js

import axios from 'axios'

export default() =&gt; {
  return axios.create({
    baseURL: `/api`,
    headers: {'Cache-Control': 'no-cache, no-store, no-transform'}
  })
}
</code></pre>
<p>You've already created a <code>server/status</code> endpoint in the server, which when the server was running you could access from <a href="http://localhost:3000/api/server/status">localhost:3000/api/server/status</a>.</p>
<p>To consume this endpoint from the client application, create a file for the service.</p>
<pre><code class="language-shell">touch src/services/Server.js
</code></pre>
<p>And, add this code to create a <code>fetchStatus</code> method on the new <code>Server</code> service.</p>
<pre><code class="language-js">// src/services/Server.js

import Api from '@/services/Api'

export default {
  fetchStatus () {
    return Api().get('server/status')
  }
}
</code></pre>
<h3>Request Server Status in the Client</h3>
<p>Now that you've created a service to make requests to the server, import the service into your <code>App.vue</code> component.</p>
<p>Open <code>App.vue</code> and add the lines as shown here.</p>
<pre><code class="language-diff">  &lt;template&gt;
    &lt;div id=&quot;app&quot;&gt;
      &lt;img alt=&quot;Vue logo&quot; src=&quot;./assets/logo.png&quot;&gt;
-     &lt;HelloWorld msg=&quot;Welcome to Your Vue.js App&quot;/&gt;
+     &lt;HelloWorld v-if=&quot;!!server.status &amp;&amp; server.status === 'ok'&quot; msg=&quot;Welcome to Your Vue.js App&quot; /&gt;
+     &lt;template v-else&gt;
+       &lt;HelloWorld msg=&quot;Connecting...&quot; /&gt;
+     &lt;/template&gt;
    &lt;/div&gt;
  &lt;/template&gt;

  &lt;script&gt;
  import HelloWorld from './components/HelloWorld.vue'
+ import ServerService from '@/services/Server'

  export default {
    name: 'App',
    components: {
      HelloWorld
+   },
+   data () {
+     return {
+       server: {},
+     }
+   },
+   mounted () {
+     this.getServerStatus()
+   },
+   methods: {
+     getServerStatus () {
+       ServerService.fetchStatus()
+         .then((response) =&gt; {
+           this.server = response.data
+         })
+     }
    }
  }
  &lt;/script&gt;

# ...
</code></pre>
<p>Here, it reuses the <strong>HelloWorld</strong> component to display the status of the request to the user.</p>
<blockquote>
<p><em><strong>Note:</strong></em> Remember, you're probably still in the client directory at this step. Starting (or restarting) the development environment again using <code>npm run dev</code> needs to run in the server directory (<code>cd ..</code> to go from client to server).</p>
</blockquote>
<p>Once it's running, you can access the client at <a href="http://localhost:8080">localhost:8080</a>. If you're quick enough, you can see the &quot;Connecting...&quot; message.</p>
<p><img src="/content/blog/building-a-slack-clone-using-vue-js-part-1/client-connecting-to-server.png" alt="Screenshot of the Vue.js client connecting to the Express.js server" title="Screenshot of the Vue.js client connecting to the Express.js server"></p>
<h2>Loading Screens with Tailwind and FontAwesome</h2>
<p>While connecting to the server in the last section, you'll have reused the <strong>HelloWorld</strong> component. Now, using the <a href="https://tailwindcss.com/">Tailwind CSS</a> low-level CSS framework and FontAwesome, create a loading screen for the client.</p>
<p>If you'd like to practice this in isolation of this app, I wrote about <a href="https://dev.to/lukeocodes/using-tailwind-css-with-vue-js-b1b">Using Tailwind CSS with Vue.js</a> in a separate guide just for you.</p>
<h3>Install Tailwind CSS</h3>
<p>To use Tailwind CSS in the client, we have to install it as a dependency and configure the client to use it.</p>
<blockquote>
<p><em><strong>Note:</strong></em> This install is for the client, not the server. So ensure you're in the <code>client</code> directory.</p>
</blockquote>
<pre><code class="language-shell">npm install tailwindcss
</code></pre>
<h3>Configure Vue.js Client for Tailwind CSS</h3>
<p>When the client app builds, it looks for a <code>postcss.config.js</code> file that is a config file that Vue.js uses to know how to process CSS. The Tailwind CSS install says you'll want to add it as a plugin in your build chain.</p>
<p>The demo app generated by Vue doesn't create a <code>postcss.config.js</code> file. Do that now.</p>
<pre><code class="language-shell">touch postcss.config.js
</code></pre>
<p>And, configure it using this code.</p>
<pre><code class="language-js">// postcss.config.js

const autoprefixer = require('autoprefixer');
const tailwindcss = require('tailwindcss');

module.exports = {
  plugins: [
    tailwindcss,
    autoprefixer,
  ],
};
</code></pre>
<h3>Add Tailwind as a CSS Asset</h3>
<p>The demo app also doesn't create any CSS assets. Instead, it uses CSS inside Vue.js components, which many guides show. So, to include tailwind, create a basic CSS file inside the assets directory using these commands or your editor.</p>
<pre><code class="language-shell">mkdir -p src/assets/styles/
touch src/assets/styles/index.css
</code></pre>
<p>Use this code to include the Tailwind CSS base, components, and utilities inside your CSS build. Copy and paste it into your new <code>index.css</code> file.</p>
<pre><code class="language-css">/* src/assets/styles/index.css */

@tailwind base;
@tailwind components;
@tailwind utilities;
</code></pre>
<h3>Include Tailwind CSS</h3>
<p>Now edit your <code>main.js</code> file to import <code>index.css</code> to the client.</p>
<pre><code class="language-diff">  // src/main.js
  import Vue from 'vue';
  import App from './App.vue';

+ import './assets/styles/index.css';

  Vue.config.productionTip = false;

  new Vue({
    render: h =&gt; h(App),
  }).$mount(`#app`);
</code></pre>
<p><img src="/content/blog/building-a-slack-clone-using-vue-js-part-1/client-styles-after-tailwind-preflight.png" alt="Screenshot of the Vue.js client styles after Tailwind CSS preflight enabled" title="Screenshot of the Vue.js client styles after Tailwind CSS preflight enabled"></p>
<blockquote>
<p><em><strong>Note:</strong></em> Tailwind CSS uses <a href="https://tailwindcss.com/docs/preflight/">preflight</a> (built on top of <a href="https://github.com/necolas/normalize.css/">normalize.css</a>) to reset all the styling on different browsers to the same place. You'll notice it's broken some default styling. Don't worry; you'll replace this altogether soon.</p>
</blockquote>
<h3>Install FontAwesome</h3>
<p>Creating a loading spinner will be done with a font awesome notched circle. Install it to the client with this command.</p>
<pre><code class="language-shell">npm install @fortawesome/fontawesome-svg-core \
            @fortawesome/free-solid-svg-icons \
            @fortawesome/vue-fontawesome \
            @fortawesome/free-regular-svg-icons \
</code></pre>
<h3>Include FontAwesome</h3>
<p>Edit <code>main.js</code> again and add this code.</p>
<pre><code class="language-diff">  // src/main.js
  import Vue from 'vue';
  import App from './App.vue';
+ import { library } from '@fortawesome/fontawesome-svg-core'
+ import { fas } from '@fortawesome/free-solid-svg-icons'
+ import { far } from '@fortawesome/free-regular-svg-icons'
+ import { FontAwesomeIcon, FontAwesomeLayers } from '@fortawesome/vue-fontawesome'

  import './assets/styles/index.css';

+ library.add(fas, far)

+ Vue.component('font-awesome-icon', FontAwesomeIcon)
+ Vue.component('font-awesome-layers', FontAwesomeLayers)

  Vue.config.productionTip = false;

  new Vue({
    render: h =&gt; h(App),
  }).$mount(`#app`);
</code></pre>
<h3>Create the Loading Screen</h3>
<p>To create a new Vue.js component to use as a loading screen, add a new component file with this command or your editor.</p>
<pre><code class="language-shell">touch source/components/Loading.vue
</code></pre>
<p>Now using this code, add the spinner to a fullscreen translucent overlay.</p>
<pre><code class="language-jsx">&lt;template&gt;
  &lt;div class=&quot;w-screen h-screen fixed block top-0 left-0 bg-white opacity-75 z-50 flex&quot;&gt;
    &lt;span class=&quot;text-green-500 opacity-75 top-1/2 m-auto text-center&quot;&gt;
      &lt;font-awesome-icon icon=&quot;circle-notch&quot; class=&quot;fa-spin fa-5x mb-2&quot; /&gt;
      &lt;p class=&quot;text-base&quot;&gt;
        {{ message }}
      &lt;/p&gt;
    &lt;/span&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  name: 'Loading',
  props: {
    message: String
  }
}
&lt;/script&gt;
</code></pre>
<p>And, add the loading screen by editing <code>App.vue</code> and replacing the reuse of <code>HelloWorld.vue</code> with the new component.</p>
<pre><code class="language-diff">  &lt;template&gt;
    &lt;div id=&quot;app&quot;&gt;
      &lt;img alt=&quot;Vue logo&quot; src=&quot;./assets/logo.png&quot;&gt;
      &lt;HelloWorld v-if=&quot;!!server.status &amp;&amp; server.status === 'ok'&quot; msg=&quot;Welcome to Your Vue.js App&quot; /&gt;
      &lt;template v-else&gt;
-       &lt;HelloWorld msg=&quot;Connecting...&quot; /&gt;
+       &lt;Loading message=&quot;Connecting...&quot; /&gt;
      &lt;/template&gt;
    &lt;/div&gt;
  &lt;/template&gt;

  &lt;script&gt;
  import HelloWorld from './components/HelloWorld.vue'
+ import Loading from '@/components/Loading.vue'
  import ServerService from '@/services/Server'

  export default {
    name: 'App',
    components: {
-     HelloWorld
+     HelloWorld,
+     Loading
    },
    data () {
      return {
        server: {},
      }
    },
    mounted () {
      this.getServerStatus()
    },
    methods: {
      getServerStatus () {
        ServerService.fetchStatus()
          .then((response) =&gt; {
            this.server = response.data
          })
      }
    }
  }
  &lt;/script&gt;

  ...
</code></pre>
<p><img src="/content/blog/building-a-slack-clone-using-vue-js-part-1/client-loading-screen-with-spinner.png" alt="Screenshot of the Vue.js client loading screen with spinner" title="Screenshot of the Vue.js client loading screen with spinner"></p>
<blockquote>
<p><em><strong>Note:</strong></em> To test this, you can modify the response <code>status</code> in the server's <code>controllers/server.js</code> directory to return something other than <code>ok</code>.</p>
</blockquote>
<h2>Handle Server Errors in the Client</h2>
<p>It is time to add error handling to the client.</p>
<h3>Catch Request Errors</h3>
<p>Edit <code>App.vue</code> and add the following code.</p>
<pre><code class="language-diff">  ...

  &lt;script&gt;
  import HelloWorld from './components/HelloWorld.vue'
  import Loading from '@/components/Loading.vue'
  import ServerService from '@/services/Server'

  export default {
    name: 'App',
    components: {
      HelloWorld,
      Loading
    },
    data () {
      return {
        server: {},
+       error: null
      }
    },
    mounted () {
      this.getServerStatus()
    },
    methods: {
      getServerStatus () {
        ServerService.fetchStatus()
          .then((response) =&gt; {
            this.server = response.data
          })
+         .catch((err) =&gt; {
+           this.error = { title: 'Couldn\'t connect to Server', message: 'There may be a problem with your connection. Please check and try again.', reason: err.reason }
+         })
      }
    }
  }
  &lt;/script&gt;

  ...
</code></pre>
<p>Now, if there is an error back from the server, it will be caught by the client and added to the component data.</p>
<h3>Create an Error Component</h3>
<p>To display an error, create an empty <code>Error.vue</code> component using this command or your editor.</p>
<pre><code class="language-shell">touch source/components/Error.vue
</code></pre>
<p>Add this code, which also uses FontAwesome icons (and layers) to produce an appropriate graphic.</p>
<pre><code class="language-jsx">&lt;template&gt;
  &lt;div class=&quot;flex h-screen&quot;&gt;
    &lt;div class=&quot;m-auto text-center w-2/3&quot;&gt;
      &lt;font-awesome-layers class=&quot;fa-10x mb-10&quot;&gt;
        &lt;font-awesome-icon icon=&quot;globe-americas&quot; transform=&quot;grow-4&quot; class=&quot;text-gray-500&quot; /&gt;
        &lt;font-awesome-icon :icon=&quot;['far', 'circle']&quot; transform=&quot;grow-5&quot; class=&quot;outline text-white&quot; /&gt;
        &lt;font-awesome-icon icon=&quot;times&quot; class=&quot;cross text-red-500&quot; transform=&quot;shrink-8 right-5 up-5&quot; /&gt;
      &lt;/font-awesome-layers&gt;
      &lt;h1 class=&quot;text-3xl mb-3 text-gray-800&quot;&gt;{{ error.title }}&lt;/h1&gt;
      &lt;p class=&quot;text-base text-gray-800&quot;&gt;{{ error.message }}&lt;/p&gt;
      &lt;p class=&quot;invisible&quot;&gt;{{ error.reason }}&lt;/p&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  name: 'Error',
  props: {
    error: Object
  }
}
&lt;/script&gt;

&lt;style scoped&gt;
.outline path {
  stroke: white;
  stroke-width: 20px;
}
.cross path {
  stroke: white;
  stroke-width: 20px;
}
&lt;/style&gt;
</code></pre>
<h3>Display a Server Error in the Client</h3>
<p>Once again editing <code>App.vue</code>, add the code as shown here. Remove the image at the same time.</p>
<pre><code class="language-diff">  &lt;template&gt;
    &lt;div id=&quot;app&quot;&gt;
-     &lt;img alt=&quot;Vue logo&quot; src=&quot;./assets/logo.png&quot;&gt;
      &lt;HelloWorld v-if=&quot;!!server.status &amp;&amp; server.status === 'ok'&quot; msg=&quot;Welcome to Your Vue.js App&quot; /&gt;
      &lt;template v-else&gt;
-       &lt;Loading message=&quot;Connecting...&quot; /&gt;
+       &lt;Loading v-if=&quot;!error&quot; message=&quot;Connecting...&quot; /&gt;
+       &lt;Error v-else :error=&quot;error&quot; /&gt;
      &lt;/template&gt;
    &lt;/div&gt;
  &lt;/template&gt;

  &lt;script&gt;
  import HelloWorld from './components/HelloWorld.vue'
+ import Error from '@/components/Error.vue'
  import Loading from '@/components/Loading.vue'
  import ServerService from '@/services/Server'

  export default {
    name: 'App',
    components: {
      HelloWorld,
+     Error,
      Loading
    },
    data () {
      return {
        server: {},
        error: null
      }
    },
    mounted () {
      this.getServerStatus()
    },
    methods: {
      getServerStatus () {
        ServerService.fetchStatus()
          .then((response) =&gt; {
            this.server = response.data
          })
          .catch((err) =&gt; {
            this.error = { title: 'Couldn\'t connect to Server', message: 'There may be a problem with your connection. Please check and try again.', reason: err.reason }
          })
      }
    }
  }
  &lt;/script&gt;

  ...
</code></pre>
<p>Now, the client displays errors sent by the server.</p>
<p><img src="/content/blog/building-a-slack-clone-using-vue-js-part-1/error-caught-by-the-server.png" alt="Screenshot of the Vue.js client catching a server error" title="Screenshot of the Vue.js client catching a server error"></p>
<blockquote>
<p><em><strong>Note:</strong></em>  To see this working, you can modify your server's application <code>controllers/server.js</code>, replacing <code>res.json</code> with <code>res.sendStatus(500)</code> to provide the client with a 500 error code.</p>
</blockquote>
<h2>Use Dotenv Environment Files</h2>
<p>You don't want to hardcode keys and credentials into your server, but especially not in your client.</p>
<h3>Install Dotenv</h3>
<p>Install <code>dotenv</code> so you can set environment variables and read them in your application.</p>
<blockquote>
<p><em><strong>Note:</strong></em> You might be in the client directory at this step. Use <code>cd ..</code> to go from client to server.</p>
</blockquote>
<pre><code class="language-shell">npm install dotenv
</code></pre>
<h3>Create an Environment File</h3>
<p>Create an empty environment file for the server using this command or your editor.</p>
<pre><code class="language-shell">touch .env
</code></pre>
<h3>Configure the Environment</h3>
<p>Now, edit <code>.env</code> and add this example configuration to the file. <strong>The token and ID are not real.</strong></p>
<pre><code class="language-shell"># server config
PORT=3000

# user config
VONAGE_USER=username
VONAGE_USER_TOKEN=eyJhbGciOiJ.SUzI1NiIsInR.5cCI6IkpXVCJ9

# app config
VONAGE_DEFAULT_CONVERSATION_ID=CON-1255bc-1c-4db7-bc48-15a46
</code></pre>
<blockquote>
<p><em><strong>Note:</strong></em> <code>.env</code> files are ignored by git due to the generated <code>.gitignore</code> file adding <code>.env</code> by default. Committing your <code>.env</code> file is about as safe as hardcoding your credentials. It also highlights that these credentials are for this environment, running it locally. If you were to deploy this, expect to manage the environment on the server in a different way. Heroku, for example, provides you with a control panel for configuring the environment.</p>
</blockquote>
<h3>Load the Environment</h3>
<p>Now, edit the server top file to include the environment when the application starts. Edit <code>bin/www</code> (it has no file extension) as shown here.</p>
<pre><code class="language-diff">  #!/usr/bin/env node

+ require('dotenv').config();

  /**
  * Module dependencies.
  */

  ...
</code></pre>
<h3>Pass Server Environment Values to the Client</h3>
<p>The first environment variable to share with the client is <code>VONAGE_DEFAULT_CONVERSATION_ID</code>, the default &quot;room&quot; ID for the chat! You'll come back and edit the value of the environment variable later.</p>
<p>Edit <code>controllers/server.js</code> and add the code shown here.</p>
<pre><code class="language-diff">  // controllers/server.js
  exports.status = function(req, res, next) {
    res.json({
+     defaultConversationId: process.env.VONAGE_DEFAULT_CONVERSATION_ID,
      status: 'ok'
    });
  };
</code></pre>
<h2>User Endpoints for Client Authentication</h2>
<p>In later parts of this series, an identity provider will manage the user data sent by the server. In the meantime, fake this information too, and come back to edit it when you have it.</p>
<h3>Create a User Endpoint</h3>
<p>Create a user endpoint by first creating a <code>user.js</code> controller using your editor or this command.</p>
<pre><code class="language-shell">touch controllers/user.js
</code></pre>
<p>Giving it this code.</p>
<pre><code class="language-js">// controllers/user.js
exports.session = function(req, res, next) {
  res.json({
    user: process.env.VONAGE_USER,
    token: process.env.VONAGE_USER_TOKEN
  });
};
</code></pre>
<p>Now, create a route to access the user controller endpoints using your editor or this command.</p>
<pre><code class="language-shell">touch routes/user.js
</code></pre>
<p>And, give it this code.</p>
<pre><code class="language-js">// routes/user.js
const express = require('express');
const router = express.Router();

const userController = require('../controllers/user');

router.get('/session', userController.session);

module.exports = router;
</code></pre>
<p>Lastly, edit your <code>app.js</code> file and add the new route as shown here.</p>
<pre><code class="language-diff">  // app.js
  var express = require('express');
  var path = require('path');
  var cookieParser = require('cookie-parser');
  var logger = require('morgan');

  var app = express();

  app.use(logger('dev'));
  app.use(express.json());
  app.use(express.urlencoded({ extended: false }));
  app.use(cookieParser());
  app.use(express.static(path.join(__dirname, 'public')));

+ app.use('/api/user', require('./routes/user'));
  app.use('/api/server', require('./routes/server'));

  module.exports = app;
</code></pre>
<p>Start the application again with <code>npm start</code>; then you can access the new route at <a href="http://localhost:3000/api/user/session">localhost:3000/api/user/session</a>.</p>
<p><img src="/content/blog/building-a-slack-clone-using-vue-js-part-1/user-session-api-endpoint.png" alt="Screenshot of a user session API endpoint" title="Screenshot of a user session API endpoint"></p>
<h2>Connect to Vonage Conversation API</h2>
<p>In this section, what follows are the usual steps if you've read one of my client-side tutorials before. If you haven't, these are simple commands to create our Vonage conversation for users to join.</p>
<h3>Set Up With Our CLI</h3>
<p>To connect to the conversations API as a user, you first need to create an application, conversation, and user.</p>
<h4>Create an Application</h4>
<p>Create an application with RTC (real-time communication) capabilities. The event URL receives a live log of events happening on the service, like users joining/leaving, sending messages. It's an example URL for the moment, but you'll be able to capture and react to events in later parts of our series.</p>
<pre><code class="language-shell">nexmo app:create &quot;Vue.js Slack Chat&quot; --capabilities=rtc --rtc-event-url=http://example.com --keyfile=private.key
# Application created: 4556dbae-bf...f6e33350d8
# Credentials written to .nexmo-app
# Private Key saved to: private.key
</code></pre>
<h4>Create a Conversation</h4>
<p>Secondly, create a conversation, which acts like a chatroom. Or, a container for messages and events.</p>
<pre><code class="language-shell">nexmo conversation:create display_name=&quot;general&quot;
# Conversation created: CON-a57b0...11e57f56d
</code></pre>
<h4>Create Your User</h4>
<p>Now, create a user for yourself.</p>
<blockquote>
<p><em><strong>Note:</strong></em> In this demo, you won't chat between two users. <a href="">Other guides</a> <a href="">show you</a> how to <a href="">create conversations</a> between <a href="">multiple users</a>. This guide focusses on styling your message UI in a simple, yet appealing, way.</p>
</blockquote>
<pre><code class="language-shell">nexmo user:create name=USER_NAME display_name=DISPLAY_NAME
# User created: USR-6eaa4...e36b8a47f
</code></pre>
<h4>Add the User to a Conversation</h4>
<p>Next, add your new user to the conversation. A user can be a member of an application, but they still need to join the conversation.</p>
<pre><code class="language-shell">nexmo member:add CONVERSATION_ID action=join channel='{&quot;type&quot;:&quot;app&quot;}' user_id=USER_ID
# Member added: MEM-df772...1ad7fa06
</code></pre>
<h4>Generate a User Token</h4>
<p>Lastly, generate your new user a token. This token represents the user when accessing the application. This access token identifies them, so anyone using it will be assumed to be the correct user.</p>
<p>In practice, you'll configure the application with this token. In production, these should be guarded, kept secret and very carefully exposed to the client application, if at all.</p>
<p>The token is only usable for 24 hours. After that, you will need to re-run this <code>nexmo jwt:generate</code> command again to grant access to your client user again.</p>
<pre><code class="language-shell">nexmo jwt:generate ./private.key sub=USER_NAME exp=$(($(date +%s)+86400)) acl='{&quot;paths&quot;:{&quot;/*/users/**&quot;:{},&quot;/*/conversations/**&quot;:{},&quot;/*/sessions/**&quot;:{},&quot;/*/devices/**&quot;:{},&quot;/*/image/**&quot;:{},&quot;/*/media/**&quot;:{},&quot;/*/applications/**&quot;:{},&quot;/*/push/**&quot;:{},&quot;/*/knocking/**&quot;:{}}}' application_id=APPLICATION_ID
# eyJhbGciOi...XVCJ9.eyJpYXQiOjE1NzM5M...In0.qn7J6...efWBpemaCDC7HtqA
</code></pre>
<h3>Store the Credentials in the Environment</h3>
<p>Now, edit <code>.env</code> and add the credentials you've now generated.</p>
<pre><code class="language-shell"># server config
PORT=3000

# user config
VONAGE_USER=username
# USER_NAME from the above commands
VONAGE_USER_TOKEN=eyJhbGciOi...XVCJ9.eyJpYXQiOjE1NzM5M...In0.qn7J6...efWBpemaCDC7HtqA
# as generated from `nexmo jwt:generate`

# app config
VONAGE_DEFAULT_CONVERSATION_ID=CON-a57b0...11e57f56d
# as generated from `nexmo conversation:create`
</code></pre>
<h3>Create a Service for the User Session</h3>
<p>Create a <code>User.js</code> service to consume the user session endpoint from the client application.</p>
<pre><code class="language-shell"># back in the client directory
cd client
</code></pre>
<p>Create the file using this command or your editor.</p>
<pre><code class="language-shell">touch src/services/User.js
</code></pre>
<p>And, add this code to create a <code>fetchSession</code> method on the new <code>User</code> service.</p>
<pre><code class="language-js">// src/services/User.js

import Api from '@/services/Api'

export default {
  fetchSession () {
    return Api().get('user/session')
  }
}
</code></pre>
<h3>Connect the Client to the Conversations API</h3>
<p>To connect the client to the Conversations API, you need to install the latest version of the <code>nexmo-client</code>.</p>
<pre><code class="language-shell">npm install nexmo-client
</code></pre>
<p>Create a new <code>Vonage.vue</code> component using your editor or the command below, which will have the responsibility of connecting to the Conversation API using the <code>nexmo-client</code> library.</p>
<pre><code class="language-shell">touch src/components/Vonage.vue
</code></pre>
<p>Similar to the <code>App.vue</code> component, the <code>Vonage.vue</code> component requests user-session information from the server, using the <code>Loading.vue</code> and <code>Error.vue</code> components in the same way, too.</p>
<pre><code class="language-jsx">&lt;template&gt;
  &lt;div&gt;
    &lt;HelloWorld v-if=&quot;!!app &amp;&amp; !!conversation&quot; msg=&quot;Welcome to Your Vue.js App&quot; /&gt;
    &lt;template v-else&gt;
      &lt;Loading v-if=&quot;!error&quot; message=&quot;Logging you in...&quot; /&gt;
      &lt;Error v-else :error=&quot;error&quot; /&gt;
    &lt;/template&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import HelloWorld from '@/components/HelloWorld.vue'
import Loading from '@/components/Loading.vue'
import Error from '@/components/Error.vue'
import UserService from '@/services/User'
import Client from 'nexmo-client'

export default {
  name: 'Vonage',
  props: {
    server: Object
  },
  components: {
    ChatWindow,
    Error,
    Loading
  },
  data () {
    return {
      app: null,
      conversation: null,
      error: null
    }
  },
  mounted () {
    this.fetchSession()
  },
  methods: {
    _errorHandler (err) {
      this.error = { title: 'Chat Service Error', message: err.reason }
    },
    fetchSession () {
      UserService.fetchSession()
        .then((response) =&gt; {
          const { token } = response.data

          new Client()
            .login(token)
            .then(app =&gt; {
              this.app = app

              return app.getConversation(this.$props.server.defaultConversationId)
            })
            .then((conversation) =&gt; {
              this.conversation = conversation
            })
            .catch(this._errorHandler)
        })
        .catch(this._errorHandler)
    }
  }
}
&lt;/script&gt;
</code></pre>
<p>Now, replace the use of the <code>HelloWorld.vue</code> with the new <code>Vonage.vue</code> component inside <code>App.vue</code> by making these changes.</p>
<pre><code class="language-diff">  &lt;template&gt;
    &lt;div id=&quot;app&quot;&gt;
-     &lt;HelloWorld v-if=&quot;!!server.status &amp;&amp; server.status === 'ok'&quot; msg=&quot;Welcome to Your Vue.js App 
+     &lt;Vonage v-if=&quot;!!server.status &amp;&amp; server.status === 'ok'&quot; :server=&quot;server&quot; /&gt;
      &lt;template v-else&gt;
        &lt;Loading v-if=&quot;!error&quot; message=&quot;Connecting...&quot; /&gt;
        &lt;Error v-else :error=&quot;error&quot; /&gt;
      &lt;/template&gt;
    &lt;/div&gt;
  &lt;/template&gt;

  &lt;script&gt;
- import HelloWorld from './components/HelloWorld.vue'
+ import Vonage from '@/components/Vonage.vue'
  import Error from '@/components/Error.vue'
  import Loading from '@/components/Loading.vue'
  import ServerService from '@/services/Server'

  export default {
    name: 'App',
    components: {
-     HelloWorld,
+     Vonage,
      Error,
      Loading
    },
    data () {
      return {
        server: {},
        error: null
      }
    },
    mounted () {
      this.getServerStatus()
    },
    methods: {
      getServerStatus () {
        ServerService.fetchStatus()
          .then((response) =&gt; {
            this.server = response.data
          })
          .catch((err) =&gt; {
            this.error = { title: 'Couldn\'t connect to Server', message: 'There may be a problem with your connection. Please check and try again.', reason: err.reason }
          })
      }
    }
  }
  &lt;/script&gt;
</code></pre>
<p>Now, after your &quot;Connecting...&quot; loading screen, you'll see a &quot;Logging you in...&quot; loading screen before it finally loads the <code>HelloWorld.vue</code> component.</p>
<p><img src="/content/blog/building-a-slack-clone-using-vue-js-part-1/client-logging-in-to-service.png" alt="Screenshot of client logging into the Conversation API" title="Screenshot of client logging into the Conversation API"></p>
<blockquote>
<p><em><strong>Note:</strong></em> You'll only reach the Hello World if your application has successfully connected to the server, got an &quot;OK&quot; status, requested the user session and then used the user's token to connect to the Conversation API using the <code>nexmo-client</code> library.</p>
</blockquote>
<h2>Create the Chat Components</h2>
<p>Now you're connected to the Conversation API; you can start creating your messaging UI. First, start with the basic structure of your application, the Chat Window.</p>
<h3>Chat Window</h3>
<p>For this, create the components <code>ChatWindow.vue</code>, <code>ChatWindowHeader.vue</code>, <code>ChatWindowEvents.vue</code>, and <code>ChatWindowFooter.vue</code> using the command or your editor.</p>
<pre><code class="language-shell">touch src/components/{ChatWindow,ChatWindowHeader,ChatWindowEvents,ChatWindowFooter}.vue
</code></pre>
<p>Editing <code>ChatWindow.vue</code>, give it the following code.</p>
<pre><code class="language-jsx">&lt;template&gt;
  &lt;div class=&quot;flex flex-col min-h-screen max-h-screen bg-white overflow-hidden&quot;&gt;
    &lt;ChatWindowHeader :channelName=&quot;'#' + conversation.display_name&quot; /&gt;
    &lt;ChatWindowEvents :conversation=&quot;conversation&quot; :user=&quot;user&quot; :members=&quot;members&quot; /&gt;
    &lt;ChatWindowFooter :conversation=&quot;conversation&quot; /&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import ChatWindowHeader from '@/components/ChatWindowHeader.vue'
import ChatWindowEvents from '@/components/ChatWindowEvents.vue'
import ChatWindowFooter from '@/components/ChatWindowFooter.vue'

export default {
  name: 'ChatWindow',
  props: {
    app: Object,
    conversation: Object
  },
  components: {
    ChatWindowHeader,
    ChatWindowEvents,
    ChatWindowFooter
  },
  data () {
    return {
      user: {},
      members: new Map(),
    }
  },
  mounted () {
    this.user = this.$props.app.me
    this.fetchMembers()
  },
  methods: {
    fetchMembers () {
      this.members = this.$props.conversation.members
    }
  }
}
&lt;/script&gt;
</code></pre>
<p>The <code>ChatWindow.vue</code> component is responsible for structuring the chat layout. Header at the top, messages in the middle, and the footer at the bottom. It passes the channel name, prefixed with a hash, as the <code>channelName</code> prop to the header. It also passes the conversation, user and members through to the events component. Then, it passes the conversation to the footer.</p>
<p>Next, edit <code>ChatWindowHeader.vue</code> and give it this code.</p>
<pre><code class="language-jsx">&lt;template&gt;
  &lt;div class=&quot;border-b flex px-6 py-2 items-center&quot;&gt;
    &lt;div class=&quot;flex flex-col&quot;&gt;
      &lt;h4 class=&quot;text-grey-darkest mb-1 font-extrabold&quot;&gt;{{ channelName }}&lt;/h4&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  name: 'ChatWindowHeader',
  props: {
    channelName: String,
    members: Number
  }
}
&lt;/script&gt;
</code></pre>
<p>The <code>ChatWindowHeader.vue</code> component, for now, just displays the channel name.</p>
<p>Now, edit <code>ChatWindowEvents.vue</code> and give it this code.</p>
<pre><code class="language-jsx">&lt;template&gt;
  &lt;div class=&quot;py-4 flex-auto overflow-y-auto&quot; ref=&quot;chatWindow&quot;&gt;
    &lt;template v-if=&quot;!!events.length&quot;&gt;
      &lt;div class=&quot;px-6 hover:bg-gray-100&quot; v-for=&quot;event in events&quot; v-bind:key=&quot;'event' + event.id&quot;&gt;
        &lt;div v-if=&quot;event.type === 'text'&quot;&gt;
          &lt;strong&gt;{{ members.get(event.from).display_name }}&lt;/strong&gt; on &lt;strong&gt;{{ event.timestamp.split(&quot;T&quot;)[0] }}&lt;/strong&gt; at &lt;strong&gt;{{ event.timestamp.split(&quot;T&quot;)[1].split(&quot;.&quot;)[0] }}&lt;/strong&gt; says {{ event.body.text }}
        &lt;/div&gt;
        &lt;div v-else-if=&quot;event.type === 'member:joined'&quot;&gt;
          &lt;strong&gt;{{ event.body.user.display_name }}&lt;/strong&gt; has joined &lt;strong&gt;#{{ event.conversation.display_name }}&lt;/strong&gt;.
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/template&gt;
    &lt;Loading v-else message=&quot;Loading messages...&quot; /&gt;
    &lt;Error v-else :error=&quot;error&quot; /&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import Loading from '@/components/Loading.vue'
import Error from '@/components/Error.vue'

export default {
  name: 'ChatWindowEvents',
  components: {
    Loading,
    Error
  },
  props: {
    user: Object,
    conversation: Object,
    members: Map,
  },
  data () {
    return {
      events: [],
      error: null
    }
  },
  mounted () {
    this.getEventHistory()
    this.registerListeners()
  },
  methods: {
    registerListeners () {
      const { conversation } = this.$props

      conversation.on('text', (user, event) =&gt; {
        this.events.push(event)
      })

      conversation.on(&quot;member:joined&quot;, (user, event) =&gt; {
        this.events.push(event)
      })
    },
    getEventHistory () {
      this.$props.conversation
        .getEvents({ page_size: 40, order: 'desc' })
        .then(eventsPage =&gt; {
          eventsPage.items.forEach(event =&gt; {
            this.events.unshift(event)
          })
        })
        .catch(err =&gt; {
          this.error = { title: 'Chat Service Error', message: err.message }
        })
    },
  },
}
&lt;/script&gt;
</code></pre>
<p>The <code>ChatWindowEvents.vue</code> component is responsible for listing all the events in the conversation. It does this top to bottom, older events being at the top of the window. Scroll down to see the most recent messages. It loads a total of 40 messages. Later in the series, you'll see how to load older messages.</p>
<p>Finally, edit <code>ChatWindowFooter.vue</code> and give it this code.</p>
<pre><code class="language-jsx">&lt;template&gt;
  &lt;div class=&quot;px-4&quot;&gt;
    &lt;textarea
      v-bind:class=&quot;{ 
        'disabled:opacity-75': isSending,
        'bg-gray-300': isSending,
        'border-gray-400': isSending,
        'border-gray-400': !isSending
      }&quot;
      v-bind:disabled=&quot;isSending&quot;
      v-bind:value=&quot;inputMessage&quot;
      v-on:input=&quot;inputMessage = $event.target.value&quot;
      v-on:keydown.enter.exact.prevent
      v-on:keyup.enter.exact=&quot;sendMessage&quot;
      v-on:keyup=&quot;typingEvents&quot;
      type=&quot;text&quot;
      :placeholder=&quot;'Message ' + conversation.display_name&quot;
      class=&quot;w-full rounded border text-sm border-gray-700 overflow-hidden py-2 px-4 resize-none&quot;
      rows=&quot;1&quot;
      ref=&quot;inputBox&quot;
    &gt;
    &lt;/textarea&gt;
    &lt;div class=&quot;grid grid-cols-10 h-6 text-xs&quot;&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  name: 'ChatWindowFooter',
  props: {
    conversation: Object,
  },
  data () {
    return {
      inputMessage: '',
      isSending: false
    }
  },
  methods: {
    typingEvents () {
      this.resizeInput()
    },
    resizeInput () {
      const inputRows = this.inputMessage.split(/\r?\n/).length
      this.$refs.inputBox.rows = inputRows
    },
    sendMessage () {
      if (this.inputMessage.replace(/\s/g,'').length &gt; 0) {
        this.isSending = true

        this.$props.conversation
          .sendText(this.inputMessage.trim())
          .then(() =&gt; {
            this.isSending = false
            this.$nextTick(() =&gt; {
              this.$refs.inputBox.focus()
              this.inputMessage = ''
              this.resizeInput()
            });
          })
          .catch(err =&gt; {
            console.error(err) // eslint-disable-line no-console
          })
      }
    }
  }
}
&lt;/script&gt;

&lt;style scoped&gt;
textarea:focus{
  outline: none;
}
&lt;/style&gt;
</code></pre>
<p>With your components created, edit <code>Vonage.vue</code> and replace <code>HelloWorld.vue</code> with your new <code>ChatWindow.vue</code> component.</p>
<pre><code class="language-diff">  &lt;template&gt;
    &lt;div&gt;
-     &lt;HelloWorld v-if=&quot;!!app &amp;&amp; !!conversation&quot; msg=&quot;Welcome to Your Vue.js App&quot; /&gt;
+     &lt;ChatWindow v-if=&quot;!!app &amp;&amp; !!conversation&quot; :app=&quot;app&quot; :conversation=&quot;conversation&quot; /&gt;
      &lt;template v-else&gt;
        &lt;Loading v-if=&quot;!error&quot; message=&quot;Logging you in...&quot; /&gt;
        &lt;Error v-else :error=&quot;error&quot; /&gt;
      &lt;/template&gt;
    &lt;/div&gt;
  &lt;/template&gt;

  &lt;script&gt;
- import HelloWorld from '@/components/HelloWorld.vue'
+ import ChatWindow from '@/components/ChatWindow.vue'
  import Loading from '@/components/Loading.vue'
  import Error from '@/components/Error.vue'
  import UserService from '@/services/User'
  import VonageClient from 'nexmo-client'

  export default {
    name: 'Vonage',
    props: {
      server: Object
    },
    components: {
-     HelloWorld,
+     ChatWindow,
      Error,
      Loading
    },
    data () {
      return {
        app: null,
        conversation: null,
        error: null
      }
    },
    mounted () {
      this.fetchSession()
    },
    methods: {
      ...
    }
  }
  &lt;/script&gt;
</code></pre>
<p>Lots to copy and paste here. Once running, see what it looks like.</p>
<p><img src="/content/blog/building-a-slack-clone-using-vue-js-part-1/chat-client-working.png" alt="Screenshot of the chat client working" title="Screenshot of the chat client working"></p>
<p>Notice the margin, leftover from the demo app! Lastly, remove this styling by editing <code>src/App.vue</code> like so.</p>
<pre><code class="language-diff">  &lt;template&gt;
    &lt;div id=&quot;app&quot;&gt;
      &lt;Vonage v-if=&quot;!!server.status &amp;&amp; server.status === 'ok'&quot; :server=&quot;server&quot; /&gt;
      &lt;template v-else&gt;
        &lt;Loading v-if=&quot;!error&quot; message=&quot;Connecting...&quot; /&gt;
        &lt;Error v-else :error=&quot;error&quot; /&gt;
      &lt;/template&gt;
    &lt;/div&gt;
  &lt;/template&gt;

  &lt;script&gt;
  ...
  &lt;/script&gt;
-
- &lt;style&gt;
- #app {
-   font-family: Avenir, Helvetica, Arial, sans-serif;
-   -webkit-font-smoothing: antialiased;
-   -moz-osx-font-smoothing: grayscale;
-   text-align: center;
-   color: #2c3e50;
-   margin-top: 60px;
- }
- &lt;/style&gt;
</code></pre>
<p>While you're at it, delete <code>HelloWorld.vue</code>. Finally.</p>
<pre><code class="language-shell">rm src/components/HelloWorld.vue
</code></pre>
<p><img src="/content/blog/building-a-slack-clone-using-vue-js-part-1/chat-client-working-beautifully.png" alt="Screenshot of the chat client working beautifully" title="Screenshot of the chat client working beautifully"></p>
<h2>Working Chat Achieved!</h2>
<p>Part 1, complete! You've built a chat client that is starting to resemble Slack. Here's a list of what you've done so far:</p>
<ul>
<li>Made an Express.js app to use as an API</li>
<li>Made a Vue.js app to use as a client</li>
<li>Created API endpoints in Express.js</li>
<li>Consumed API endpoints in Vue.js</li>
<li>Added hot reloading of Express.js files</li>
<li>Added concurrently to Express.js and Vue.js with one command</li>
<li>Proxied API requests from Vue.js to Express.js</li>
<li>Styled Vue.js with Tailwind CSS</li>
<li>Animated icons with FontAwesome</li>
<li>Made a full-screen loading component</li>
<li>Connected to the Vonage Conversation API</li>
<li>Created a Messaging UI</li>
</ul>
<p>If you're interested in the demo app complete, please check out the <a href="https://github.com/nexmo-community/vuejs-slack-clone/tree/part-1">GitHub repo for my Vue.js Slack clone</a> so far.</p>
<p>Stay tuned for part 2, where we tackle the following user experience must-haves.</p>
<ul>
<li>Infinite scrolling history</li>
<li>Sticky scroll positions when scrolling history</li>
<li>Ping to bottom on sending messages</li>
<li>Unread message notifications</li>
<li>Mark-as-read button</li>
<li>Number of channel members</li>
<li>Message deletion</li>
<li>User typing events notification (several people are typing)</li>
<li>Multi-line messages</li>
<li>Slack style Markdown</li>
</ul>
<p>By the end of Part 2, you'll have something that looks more like this!</p>
<p><img src="/content/blog/building-a-slack-clone-using-vue-js-part-1/chat-part-2-sneak-peek.png" alt="Screenshot of the sneak peek of chat from Part 2" title="Screenshot of the sneak peek of chat from Part 2"></p>
<h2>Further Reading</h2>
<p>Here are some more articles you may find helpful in your journey to create a web-based chat app.</p>
<ul>
<li><a href="https://www.nexmo.com/blog/2019/10/11/adding-voice-functionality-to-an-existing-chat-application-dr">Adding Voice Functionality to an Existing Chat Application</a></li>
<li><a href="https://www.nexmo.com/blog/2019/11/20/register-to-chat-with-typeform-dr">Register to Chat with Typeform</a></li>
<li><a href="https://developer.nexmo.com/client-sdk/overview">JavaScript Client SDK Overview</a></li>
<li><a href="https://www.nexmo.com/blog/2019/12/18/create-a-simple-messaging-ui-with-bootstrap-dr">Create a Simple Messaging UI with Bootstrap</a></li>
<li><a href="https://www.nexmo.com/blog/2020/02/03/chat-pagination-with-infinite-scrolling-dr">Chat Pagination with Infinite Scrolling</a></li>
</ul>
<p>And dont forget, if you have any questions, advice or ideas youd like to share with the community, then please feel free to jump on our <a href="https://developer.nexmo.com/community/slack">Community Slack workspace</a> or pop a reply below </p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[My first blog post 2]]></title>
            <link>/blog/my-first-blog-post-2</link>
            <guid>/blog/my-first-blog-post-2</guid>
            <description><![CDATA[Vonage Video API (formerly TokBox OpenTok) and what you can build with it. The Video API is very robust and highly customisable, and in each post well show how to implement it.]]></description>
            <content:encoded><![CDATA[<p>Hey Everyone, this is simple a test blog post to show you
the functionality of nuxt markdown blog.</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[My first blog post]]></title>
            <link>/blog/my-first-blog-post</link>
            <guid>/blog/my-first-blog-post</guid>
            <description><![CDATA[Vonage Video API (formerly TokBox OpenTok) and what you can build with it. The Video API is very robust and highly customisable, and in each post well show how to implement it.]]></description>
            <content:encoded><![CDATA[<p>Hey Everyone, this is simple a test blog post to show you
the functionality of nuxt markdown blog.</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Lauren Learns Things w/ Tony Hung]]></title>
            <link>/twitch/lauren-learns-things-w-tony-hung-machine-learning</link>
            <guid>/twitch/lauren-learns-things-w-tony-hung-machine-learning</guid>
            <description><![CDATA[Vonage Video API (formerly TokBox OpenTok) and what you can build with it. The Video API is very robust and highly customisable, and in each post well show how to implement it.]]></description>
            <content:encoded><![CDATA[<p>Lauren Learns Things w/ Tony Hung April 7th 2:00pm EDT- How to build a Machine Learning model that classifies spam messages</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Nexmo: Loved by developers - Built for business]]></title>
            <link>/youtube/nexmo-loved-by-developers-built-for-business</link>
            <guid>/youtube/nexmo-loved-by-developers-built-for-business</guid>
            <description><![CDATA[Vonage Video API (formerly TokBox OpenTok) and what you can build with it. The Video API is very robust and highly customisable, and in each post well show how to implement it.]]></description>
            <content:encoded><![CDATA[<p>Meet Nexmo, The Vonage API Platform. Integrated with Vonage's carrier-grade network, the Nexmo API platform delivers powerful SMS and chat solutions and a deeply rich programmable voice experience. Build with Nexmo to make every customer interaction count.</p>
]]></content:encoded>
        </item>
    </channel>
</rss>